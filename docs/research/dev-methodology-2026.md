# AI-First 개발 방법론 & 도구 연구 (2026)

> 최종 업데이트: 2026-02-07
> 대상: 솔로 개발자 / 소규모 팀, Next.js 15 + Supabase + Vercel 웹앱

---

## 목차

1. [AI-First 개발 방법론](#1-ai-first-개발-방법론)
2. [Next.js 15 + Supabase 베스트 프랙티스](#2-nextjs-15--supabase-베스트-프랙티스)
3. [PRD/TRD 템플릿](#3-prdtrd-템플릿)
4. [Claude Code 개발 워크플로우](#4-claude-code-개발-워크플로우)
5. [Monorepo vs Single App](#5-monorepo-vs-single-app)
6. [MVP 테스트 전략](#6-mvp-테스트-전략)
7. [CI/CD 베스트 프랙티스](#7-cicd-베스트-프랙티스)
8. [코드 품질 도구 설정](#8-코드-품질-도구-설정)
9. [실행 권장사항 요약](#9-실행-권장사항-요약)

---

## 1. AI-First 개발 방법론

### 1.1 핵심 마인드셋 전환

2026년 개발 환경에서 가장 중요한 변화는 **역할의 재정의**다.

> "코드를 직접 작성하는 사람이 아니라, AI 개발팀의 매니저로서 역할을 재정의해야 한다."
> -- [AI-First Development Field Guide](https://www.makingdatamistakes.com/ai-first-development/)

- Stack Overflow 2025 조사: 개발자 84%가 AI 도구 사용 중/계획, 51%가 매일 사용
- Google DORA 2025 리포트: 소프트웨어 전문가 90%가 AI 사용, 하루 중앙값 2시간 AI 활용
- 솔로 개발자의 경우 하나의 "메인 드라이버"(IDE copilot) + 하나의 "전략 브레인"(채팅 도구)으로 90% 커버 가능

### 1.2 Spec-Driven Development (스펙 주도 개발)

**Addy Osmani의 LLM 코딩 워크플로우** (2026년 기준 가장 검증된 접근법):

> "경험 있는 LLM 개발자들은 견고한 스펙/계획을 워크플로우의 초석으로 삼는다.
> 계획을 먼저 세우면 개발자와 AI가 같은 페이지에 있게 되어 낭비를 방지한다."
> -- [Addy Osmani, My LLM Coding Workflow Going into 2026](https://addyosmani.com/blog/ai-coding-workflow/)

**6단계 워크플로우:**

```
1. Planning & Specification (계획 & 스펙)
   → AI와 상세 요구사항 브레인스토밍
   → 반복적으로 가정 명확화
   → spec.md 작성 (요구사항, 아키텍처, 데이터 모델, 테스트 전략)

2. Project Planning (프로젝트 계획)
   → 스펙을 추론 모델에 전달
   → "논리적이고 작은 마일스톤으로 분해"
   → 코딩 전 상세 로드맵 생성

3. Iterative Implementation (반복적 구현)
   → 한 번에 하나의 함수/기능/버그
   → 모놀리식 출력 요청 금지
   → 각 조각은 테스트 가능하고 이해 가능해야 함

4. Context Provision (컨텍스트 제공)
   → 관련 코드, 프로젝트 제약조건, API 문서, 선호 접근법

5. Verification & Testing (검증 & 테스트)
   → 모든 생성 코드 철저히 리뷰
   → 자동 테스트 실행
   → CI 파이프라인으로 이른 이슈 포착

6. Version Control & Iteration (버전 관리 & 반복)
   → 성공적 작업마다 커밋 ("세이브 포인트")
   → AI 제안이 문제 일으키면 빠른 되돌리기
```

### 1.3 Human-in-the-Loop vs Human-on-the-Loop

| 모드                         | 설명                                   | 사용 시점                                    |
| ---------------------------- | -------------------------------------- | -------------------------------------------- |
| **HITL** (Human-in-the-Loop) | AI가 옵션 제안, 인간이 실행 전 검증    | 고위험 작업 (DB 스키마, 인증, 배포)          |
| **HOTL** (Human-on-the-Loop) | 시스템 자율 운영, 인간이 모니터링/개입 | 저위험 반복 작업 (린트, 포맷팅, 간단한 CRUD) |

**Chaekdam 프로젝트 권장:**

- DB 마이그레이션, Auth 설정: HITL
- UI 컴포넌트, 유틸 함수, 테스트 작성: HOTL

### 1.4 AI 최적화 아키텍처 원칙

[AI-First Development 가이드](https://www.makingdatamistakes.com/ai-first-development/)에서 추출한 핵심 원칙:

- **훈련 데이터가 풍부한 언어 선택**: TypeScript, Python, JavaScript
- **이국적인 기술 스택 회피**: API 버전 변경이 잦은 것 피하기
- **풀스택 단일 언어**: TypeScript
- **AI 친화적 호스팅**: CLI/config 기반 오케스트레이션 (Supabase, Vercel이 모범)
- **설명적 파일명**: `database_autogenerated.ts` > `database.ts`
- **긴 변수명**: grep 가능하고 AI가 이해하기 쉽도록

---

## 2. Next.js 15 + Supabase 베스트 프랙티스

### 2.1 프로젝트 초기 설정

**공식 권장 방법** ([Supabase Docs](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)):

```bash
# Vercel 공식 템플릿으로 시작 (권장)
npx create-next-app -e with-supabase chaekdam

# 또는 수동 설정
npx create-next-app@latest chaekdam --typescript --tailwind --eslint --app --src-dir
npm install @supabase/supabase-js @supabase/ssr
```

### 2.2 환경 변수

```env
# .env.local
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

### 2.3 Supabase 클라이언트 구조 (SSR 필수)

Next.js는 브라우저와 서버 두 곳에서 코드를 실행하므로, 별도의 클라이언트가 필요하다.

```
/utils/supabase/
  client.ts    → 브라우저용 (createBrowserClient)
  server.ts    → Server Component/Route Handler용 (createServerClient)
  middleware.ts → 미들웨어에서 세션 갱신용
```

**핵심 주의사항:**

- `@supabase/ssr` 패키지 필수 -- 쿠키 처리를 올바르게 해야 세션 유지
- 쿠키 설정 잘못하면 하이드레이션 에러 또는 세션 미유지 발생
- Row Level Security (RLS)가 기본 활성 -- 정책 추가 전에는 빈 배열 반환

### 2.4 미들웨어로 보호 라우트

```typescript
// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  // updateSession으로 쿠키 갱신 + 인증 확인
  // 미인증 시 /login으로 리다이렉트
}

export const config = {
  matcher: ["/dashboard/:path*", "/groups/:path*"],
};
```

### 2.5 인증 전략

| 방법                      | 장점                  | Chaekdam 권장              |
| ------------------------- | --------------------- | -------------------------- |
| **OAuth** (Google, Kakao) | 보안 + 사용 편의 균형 | 1순위 -- Kakao 한국 사용자 |
| **Magic Link**            | 가장 간단한 UX        | 2순위 -- 이메일 기반       |
| **Email/Password**        | 전통적                | 3순위 -- 필요 시           |

### 2.6 실시간 기능

Supabase Realtime + Next.js 15 조합:

- 독서 모임 채팅
- 리뷰 실시간 업데이트
- 모임 일정 변경 알림

### 2.7 타입 자동 생성

```bash
# Supabase CLI로 TypeScript 타입 자동 생성
npx supabase gen types typescript --project-id your-project-id > types/supabase.ts
```

---

## 3. PRD/TRD 템플릿

### 3.1 AI 개발에 최적화된 PRD 구조

전통적 PRD는 인간 팀을 위한 것이었지만, 2026년에는 **AI가 소비하는 PRD**가 더 중요해졌다.

> "PRD가 정적 문서에서 AI 에이전트와 인간 팀 모두를 체계적으로 안내하는 **살아있는 문서**로 변해야 한다."
> -- [UXPin, Structure AI-Assisted Development with PRDs](https://www.uxpin.com/studio/blog/structure-ai-assisted-development-prds/)

### 3.2 권장 PRD 템플릿 (Chaekdam 맞춤)

```markdown
# [기능명] PRD

## 1. 개요

- 한 줄 요약: [이 기능이 해결하는 문제]
- 우선순위: P0/P1/P2
- 예상 소요: [시간/일]

## 2. 문제 정의

- 사용자 페인포인트
- 현재 상태 vs 목표 상태

## 3. 사용자 스토리

- As a [역할], I want to [행동] so that [목적]
- 수용 기준 (Acceptance Criteria): 구체적이고 테스트 가능한 조건

## 4. 기술 스펙

### 4.1 데이터 모델

- 테이블/컬럼 정의
- RLS 정책

### 4.2 API 엔드포인트

- HTTP 메서드, 경로, 요청/응답 형식

### 4.3 UI 컴포넌트

- 컴포넌트 트리
- 상태 관리

### 4.4 의존성

- 다른 기능과의 연관관계

## 5. 구현 계획

- [ ] Step 1: [구체적 작업]
- [ ] Step 2: [구체적 작업]
- [ ] Step 3: [테스트]

## 6. 엣지 케이스 & 제약조건

- 인증 안 된 사용자
- 빈 데이터
- 네트워크 에러

## 7. 테스트 전략

- 단위 테스트 대상
- E2E 시나리오

## 8. 결정 로그

| 날짜 | 결정 | 근거 |
| ---- | ---- | ---- |
```

### 3.3 Prompt Requirements Document (새 개념)

2026년 등장한 새 개념 -- **Prompt Requirements Document**:

> "Prompt Requirements Document는 인간-AI 협업을 위한 구조화된 접근법으로,
> 프로젝트 컨텍스트, 기술적 근거, 아키텍처 결정을 확립하여
> AI 어시스턴트와 인간 팀원이 같은 이해에서 작업하도록 보장한다."
> -- [Takafumi Endo, Medium](https://medium.com/@takafumi.endo/prompt-requirements-document-prd-a-new-concept-for-the-vibe-coding-era-0fb7bf339400)

**기존 PRD와의 차이:**

- 기존 PRD: 인간이 인간에게 전달
- Prompt PRD: 인간이 AI에게 전달 (AI가 소비하기 쉬운 형식)
- AI 에이전트의 컨텍스트 윈도우에 맞는 간결한 형식
- 코드 예시와 파일 경로를 직접 포함

### 3.4 TRD (Technical Requirements Document) 경량 템플릿

```markdown
# [기능명] TRD

## 아키텍처

- 패턴: [Server Component / Client Component / API Route]
- 데이터 흐름: [다이어그램 또는 설명]

## 데이터베이스

- 새 테이블/컬럼
- 마이그레이션 SQL
- RLS 정책

## API 설계

- 엔드포인트 목록
- 인증 요구사항
- 에러 처리 전략

## 성능 고려사항

- 캐싱 전략
- 쿼리 최적화

## 보안

- 입력 검증
- 권한 확인
```

---

## 4. Claude Code 개발 워크플로우

### 4.1 공식 베스트 프랙티스 4단계

[Claude Code Best Practices](https://code.claude.com/docs/en/best-practices)에서 권장하는 핵심 워크플로우:

```
Phase 1: Explore (탐색)
  → Plan Mode에서 파일 읽기, 질문 응답, 코드 변경 없음
  → "src/auth를 읽고 세션과 로그인이 어떻게 처리되는지 이해해줘"

Phase 2: Plan (계획)
  → 상세 구현 계획 생성 요청
  → "Google OAuth를 추가하려 해. 어떤 파일을 변경해야 해? 계획을 세워줘"
  → Ctrl+G로 텍스트 에디터에서 계획 직접 편집

Phase 3: Implement (구현)
  → Normal Mode로 전환, 계획에 따라 코딩
  → "계획에 따라 OAuth 플로우 구현해. 콜백 핸들러 테스트 작성하고 테스트 돌려"

Phase 4: Commit (커밋)
  → 설명적 메시지와 함께 커밋 & PR
  → "설명적인 메시지로 커밋하고 PR 열어줘"
```

### 4.2 CLAUDE.md 최적화

**핵심 원칙:** 모든 단어가 컨텍스트 토큰을 소비 -- **50-100줄**, 최대 300줄

```markdown
# CLAUDE.md 예시 (Chaekdam 프로젝트)

# 프로젝트 개요

Reading group web app (Next.js 15 + Supabase + Vercel)

# 코드 스타일

- ES modules (import/export) 사용, CommonJS (require) 금지
- 가능하면 named exports 사용
- React 함수 컴포넌트 + TypeScript strict mode
- Tailwind CSS 유틸리티 클래스 사용

# 명령어

- `npm run dev` -- 개발 서버 (포트 3000)
- `npm run build` -- 프로덕션 빌드
- `npm run lint` -- ESLint 실행
- `npm run test` -- Vitest 단위 테스트
- `npm run test:e2e` -- Playwright E2E 테스트
- `npx supabase gen types typescript --project-id $PROJECT_ID > types/supabase.ts`

# 아키텍처

- App Router 사용 (pages 아닌 app 디렉토리)
- Server Components 기본, 필요시만 'use client'
- Supabase 클라이언트는 /utils/supabase/ 에서 가져오기
- DB 타입은 /types/supabase.ts 참조

# 주의사항

- Supabase RLS 활성 -- 새 테이블엔 반드시 정책 추가
- 미들웨어에서 updateSession 호출 필수
- .env.local은 커밋 금지
```

**추가 파일은 @ 구문으로 임포트:**

```markdown
# CLAUDE.md

@README.md 프로젝트 개요
@docs/architecture.md 아키텍처 상세

# 추가 지침

- Git 워크플로우: @docs/git-instructions.md
```

### 4.3 Skills & Subagents 활용

**Skills** (`.claude/skills/`): 도메인 지식과 재사용 워크플로우

```markdown
# .claude/skills/fix-issue/SKILL.md

---

name: fix-issue
description: GitHub 이슈 수정
disable-model-invocation: true

---

GitHub 이슈 분석 및 수정: $ARGUMENTS

1. `gh issue view`로 이슈 상세 확인
2. 문제 이해
3. 관련 파일 코드베이스 검색
4. 필요한 변경 구현
5. 테스트 작성 및 실행
6. 린트/타입 체크 통과 확인
7. 설명적 커밋 메시지 작성
8. Push 후 PR 생성
```

**Subagents**: 별도 컨텍스트에서 격리된 작업 수행

```markdown
# .claude/agents/security-reviewer.md

---

name: security-reviewer
description: 보안 취약점 코드 리뷰
tools: Read, Grep, Glob, Bash
model: opus

---

시니어 보안 엔지니어로서 코드 리뷰:

- 인젝션 취약점 (SQL, XSS, 커맨드 인젝션)
- 인증/권한 결함
- 코드 내 시크릿/자격증명
- 안전하지 않은 데이터 처리
```

### 4.4 컨텍스트 관리 전략

Claude Code의 **가장 중요한 리소스는 컨텍스트 윈도우**:

| 전략                         | 설명                                                                      |
| ---------------------------- | ------------------------------------------------------------------------- |
| `/clear`                     | 관련 없는 작업 사이에 컨텍스트 리셋                                       |
| `/compact <지시>`            | 특정 부분에 집중하여 요약                                                 |
| Subagent 위임                | 파일 탐색은 서브에이전트에 위임 → 메인 컨텍스트 보존                      |
| `/rewind`                    | 이전 체크포인트로 대화/코드 복원                                          |
| 2번 수정 후 실패 시 `/clear` | 실패한 접근법이 컨텍스트 오염 → 깨끗한 세션에서 더 나은 프롬프트로 재시작 |

### 4.5 Chaekdam 프로젝트 개발 사이클

```
매일의 개발 루프:

1. 기능 선택 → PRD 작성/확인
2. Claude Code Plan Mode에서 탐색
   → "이 기능과 관련된 기존 코드를 분석해줘"
3. 구현 계획 생성 & 리뷰
4. Normal Mode에서 구현
   → 한 번에 하나의 파일/함수씩
   → 각 단계 후 테스트 실행
5. 검증
   → Vitest 단위 테스트
   → Playwright E2E (핵심 플로우)
   → TypeScript 타입 체크
6. 커밋 (인간이 리뷰 후)
7. /clear 후 다음 기능으로
```

---

## 5. Monorepo vs Single App

### 5.1 결론: Chaekdam은 Single App으로 시작

| 기준                    | Single App    | Monorepo               |
| ----------------------- | ------------- | ---------------------- |
| **초기 복잡도**         | 낮음          | 중간-높음              |
| **설정 시간**           | 없음          | Turborepo/nx 학습 필요 |
| **솔로 개발자 적합도**  | 최적          | 과잉                   |
| **코드 공유 필요**      | 없음 (앱 1개) | 여러 앱 간 공유 시     |
| **Vercel 배포**         | 단순          | 가능하나 설정 필요     |
| **나중에 마이그레이션** | 쉬움          | -                      |

**근거:**

> "앱이 하나뿐이라면 모노레포나 npm 링킹이 필요하지 않을 수 있다."
> -- [ProNext.js, Should You Use a Monorepo?](https://www.pronextjs.dev/workshops/next-js-production-project-setup-and-infrastructure-fq4qc/should-you-use-a-monorepo-w6lx7)

> "모노레포로의 마이그레이션은 즉시 결정할 필요가 없다 -- 나중에 쉽게 마이그레이션 가능하다."
> -- [LogRocket, Build Monorepo Next.js](https://blog.logrocket.com/build-monorepo-next-js/)

### 5.2 나중에 Monorepo 고려할 시점

- 별도 관리자 앱이 필요할 때
- 독립적인 마이크로서비스/패키지 추가 시
- 디자인 시스템 패키지 분리 시

---

## 6. MVP 테스트 전략

### 6.1 테스트 피라미드 (MVP 경량 버전)

```
        /\
       /  \
      / E2E \          3-5개 핵심 플로우 (Playwright)
     /--------\
    /Integration\      API 라우트 + DB 쿼리 (Vitest)
   /--------------\
  /   Unit Tests    \   유틸 함수, 헬퍼 (Vitest)
 /--------------------\
/   Type Safety (TS)    \  전체 코드베이스 (TypeScript strict)
```

### 6.2 MVP에서의 테스트 우선순위

| 우선순위 | 대상                   | 도구         | 이유                              |
| -------- | ---------------------- | ------------ | --------------------------------- |
| **P0**   | TypeScript strict mode | tsc --noEmit | 무료 버그 방지, 즉시 피드백       |
| **P0**   | 핵심 E2E 3-5개         | Playwright   | 사용자 관점 핵심 플로우 보장      |
| **P1**   | API 래퍼/유틸 함수     | Vitest       | 순수 함수 → 테스트 쉬움, ROI 높음 |
| **P2**   | UI 컴포넌트            | Vitest + RTL | 시간 나면 추가                    |
| **P3**   | 스냅샷 테스트          | Vitest       | MVP에선 불필요                    |

### 6.3 Next.js 15 테스트 주의사항

[Next.js 공식 가이드](https://nextjs.org/docs/app/guides/testing)의 핵심:

- **async Server Components**는 Vitest가 완전 지원 안 함 → **E2E 테스트로 커버**
- 동기 Server/Client Components는 단위 테스트 가능
- Vitest는 `@vitejs/plugin-react`와 함께 설정

### 6.4 핵심 E2E 시나리오 (Chaekdam)

```
1. 회원가입 → 로그인 → 프로필 설정
2. 독서 모임 생성 → 멤버 초대 → 참여
3. 책 검색 → 독서 모임에 추가 → 리뷰 작성
4. (실시간) 채팅 메시지 전송 → 수신 확인
5. (관리) 모임 설정 변경 → 멤버 관리
```

### 6.5 2026년 테스트 전략 트렌드

> "2026년 테스트는 계층화된 풀스택 전략이 최적: Vitest로 ESM 프로젝트,
> React Testing Library로 사용자 중심 컴포넌트 테스트,
> MSW로 API/통합 체크, 소수의 Playwright E2E를 CI에 연결"
> -- [NuCamp, Testing in 2026](https://www.nucamp.co/blog/testing-in-2026-jest-react-testing-library-and-full-stack-testing-strategies)

---

## 7. CI/CD 베스트 프랙티스

### 7.1 Vercel + GitHub 통합 (기본)

**Chaekdam 권장: Vercel Git Integration (기본) + GitHub Actions (테스트만)**

Vercel은 Git push 시 자동 배포를 기본 제공하므로, 배포 자체는 Vercel에 맡기고 GitHub Actions는 테스트/린트만 담당.

### 7.2 GitHub Actions 워크플로우

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - run: npm ci
      - run: npm run lint
      - run: npm run typecheck
      - run: npm run test

  e2e:
    runs-on: ubuntu-latest
    needs: quality
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - run: npm ci
      - run: npx playwright install --with-deps
      - run: npm run build
      - run: npm run test:e2e
    env:
      NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
```

### 7.3 Vercel 설정

```json
// vercel.json (최소)
{
  "framework": "nextjs"
}
```

**GitHub Secrets에 저장:**

- `VERCEL_ORG_ID`
- `VERCEL_PROJECT_ID`
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`

### 7.4 배포 전략

```
Feature Branch → PR 생성 → GitHub Actions (린트 + 테스트)
                          → Vercel Preview 배포 (자동)
                          → 리뷰 & 승인
                          → main 머지 → Vercel Production 배포 (자동)
```

### 7.5 비용 최적화 (솔로 개발자)

- GitHub Actions: **Public 레포 = 무제한**, Private = 월 2,000분 무료
- Vercel: Hobby 플랜 무료 (개인 프로젝트)
- Supabase: Free 플랜 (2개 프로젝트, 500MB DB, 1GB 스토리지)

---

## 8. 코드 품질 도구 설정

### 8.1 필수 패키지

```bash
# ESLint (Next.js 15 기본 포함) + Prettier + Husky + lint-staged
npm install -D prettier eslint-config-prettier husky lint-staged
```

### 8.2 ESLint 설정 (Next.js 15 Flat Config)

```javascript
// eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends(
    "next/core-web-vitals",
    "next/typescript",
    "prettier" // Prettier 충돌 방지 (반드시 마지막)
  ),
  {
    rules: {
      // 프로젝트별 규칙
      "@typescript-eslint/no-unused-vars": [
        "error",
        {
          argsIgnorePattern: "^_",
          varsIgnorePattern: "^_",
        },
      ],
      "prefer-const": "error",
    },
  },
];

export default eslintConfig;
```

### 8.3 Prettier 설정

```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "tabWidth": 2,
  "printWidth": 100,
  "plugins": ["prettier-plugin-tailwindcss"]
}
```

```
// .prettierignore
node_modules
.next
.vercel
coverage
types/supabase.ts
```

### 8.4 Husky + lint-staged 설정

```bash
# Husky 초기화
npx husky init
```

```javascript
// lint-staged.config.mjs
export default {
  "*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"],
  "*.{json,css,md}": ["prettier --write"],
};
```

```bash
# .husky/pre-commit
npx lint-staged
```

### 8.5 package.json 스크립트

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

### 8.6 VS Code 설정 (팀 공유)

```json
// .vscode/settings.json
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "typescript.preferences.importModuleSpecifier": "non-relative"
}
```

### 8.7 추가 권장 도구

| 도구                            | 용도                           | 설정                     |
| ------------------------------- | ------------------------------ | ------------------------ |
| **prettier-plugin-tailwindcss** | Tailwind 클래스 자동 정렬      | .prettierrc plugins 배열 |
| **@total-typescript/ts-reset**  | 더 나은 TS 기본 타입           | tsconfig에 추가          |
| **knip**                        | 사용하지 않는 코드/의존성 탐지 | 주기적 실행              |

---

## 9. 실행 권장사항 요약

### Chaekdam 프로젝트에 적용할 핵심 결정

| 항목       | 결정                                    | 근거                                        |
| ---------- | --------------------------------------- | ------------------------------------------- |
| **구조**   | Single App                              | 솔로 개발, 앱 1개, 나중에 마이그레이션 가능 |
| **방법론** | Spec-Driven + Claude Code 4단계         | 검증된 AI 개발 워크플로우                   |
| **PRD**    | 기능별 경량 PRD + CLAUDE.md             | AI가 소비 가능한 형식                       |
| **테스트** | TS strict + E2E 5개 + 유틸 단위         | MVP에 적합한 최소 테스트                    |
| **CI/CD**  | Vercel 자동배포 + GHA 테스트            | 무료, 단순, 효과적                          |
| **품질**   | ESLint + Prettier + Husky + lint-staged | 커밋 전 자동 체크                           |
| **인증**   | Kakao OAuth 우선                        | 한국 사용자 대상                            |
| **DB**     | Supabase + RLS + 타입 자동생성          | 보안 + 타입 안전                            |

### 일일 개발 루틴

```
Morning:
  1. PRD에서 오늘의 기능 확인
  2. Claude Code: Explore → Plan → Implement → Verify
  3. 기능 완료마다 커밋

Afternoon:
  4. E2E 테스트 추가/실행
  5. PR 생성 → Vercel Preview 확인
  6. main 머지 → Production 배포

Evening:
  7. CLAUDE.md 업데이트 (새 gotchas, 패턴)
  8. 내일 기능 PRD 초안
```

---

## 10. 출처

### AI-First 개발 방법론

- [AI-Assisted Development in 2026 - DEV Community](https://dev.to/austinwdigital/ai-assisted-development-in-2026-best-practices-real-risks-and-the-new-bar-for-engineers-3fom)
- [AI-First Development Field Guide](https://www.makingdatamistakes.com/ai-first-development/)
- [Addy Osmani, My LLM Coding Workflow Going into 2026](https://addyosmani.com/blog/ai-coding-workflow/)
- [How to Actually Use AI as a Developer in 2026](https://www.thatsoftwaredude.com/content/14227/how-to-actually-use-ai-as-a-developer-in-2026)
- [AI-Driven Development Lifecycle 2026](https://han.guru/papers/ai-dlc-2026/)

### Next.js + Supabase

- [Supabase + Next.js 공식 가이드](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Build a User Management App with Next.js - Supabase Docs](https://supabase.com/docs/guides/getting-started/tutorials/with-nextjs)
- [Supabase + Next.js Guide - The Real Way](https://medium.com/@iamqitmeeer/supabase-next-js-guide-the-real-way-01a7f2bd140c)
- [Building Real-time Supabase Subscriptions in Next.js 15](https://dev.to/lra8dev/building-real-time-magic-supabase-subscriptions-in-nextjs-15-2kmp)

### Claude Code 워크플로우

- [Claude Code Best Practices (공식)](https://code.claude.com/docs/en/best-practices)
- [Claude Code Common Workflows (공식)](https://code.claude.com/docs/en/common-workflows)
- [The Complete Guide to CLAUDE.md - Builder.io](https://www.builder.io/blog/claude-md-guide)
- [Writing a Good CLAUDE.md - HumanLayer](https://www.humanlayer.dev/blog/writing-a-good-claude-md)
- [Claude Code Complete Guide 2026](https://claude-world.com/articles/claude-code-complete-guide-2026/)
- [Plan-Driven Development - DeepWiki](https://deepwiki.com/FlorianBruniaux/claude-code-ultimate-guide/10.3-plan-driven-development)
- [Claude Code End-to-End SDLC Workflow](https://developersvoice.com/blog/ai/claude_code_2026_end_to_end_sdlc/)

### PRD 템플릿

- [AI PRD Template by Miqdad Jaffer (OpenAI)](https://www.productcompass.pm/p/ai-prd-template)
- [Structure AI-Assisted Development with PRDs - UXPin](https://www.uxpin.com/studio/blog/structure-ai-assisted-development-prds/)
- [Prompt Requirements Document (PRD) for Vibe Coding Era](https://medium.com/@takafumi.endo/prompt-requirements-document-prd-a-new-concept-for-the-vibe-coding-era-0fb7bf339400)
- [Using AI to Write PRD - ChatPRD](https://www.chatprd.ai/resources/using-ai-to-write-prd)

### 테스트 전략

- [Next.js Testing Guide (공식)](https://nextjs.org/docs/app/guides/testing)
- [Next.js Vitest Setup Guide (공식)](https://nextjs.org/docs/app/guides/testing/vitest)
- [Testing in 2026: Jest, RTL, and Full Stack Strategies](https://www.nucamp.co/blog/testing-in-2026-jest-react-testing-library-and-full-stack-testing-strategies)
- [Setting up Vitest for Next.js 15 - Wisp CMS](https://www.wisp.blog/blog/setting-up-vitest-for-nextjs-15)

### CI/CD

- [Vercel + GitHub Actions 공식 가이드](https://vercel.com/kb/guide/how-can-i-use-github-actions-with-vercel)
- [Vercel CI/CD GitHub Actions Examples](https://github.com/vercel/examples/tree/main/ci-cd/github-actions)
- [Building CI/CD with Vercel and GitHub Actions - Zealous](https://www.zealousys.com/blog/building-a-ci-cd-pipeline-with-vercel-and-github-actions/)

### 코드 품질 도구

- [Next.js ESLint 설정 (공식)](https://nextjs.org/docs/app/api-reference/config/eslint)
- [ESLint, Prettier, Husky Setup - FreeCodeCamp](https://www.freecodecamp.org/news/how-to-set-up-eslint-prettier-stylelint-and-lint-staged-in-nextjs/)
- [Complete Next.js Setup Guide - JB](https://jb.desishub.com/blog/nextjs-setup-with-husky-and-lint-staged)

### MVP 전략

- [MVP Development Guide 2026 - Creole Studios](https://www.creolestudios.com/mvp-development-guide/)
- [MVP Tech Stack Guide 2026 - Cabot Solutions](https://www.cabotsolutions.com/blog/mvp-development-tools-and-tech-stack-every-founder-should-know-in-2026)

### Monorepo

- [Should You Use a Monorepo? - ProNext.js](https://www.pronextjs.dev/workshops/next-js-production-project-setup-and-infrastructure-fq4qc/should-you-use-a-monorepo-w6lx7)
- [Build Monorepo in Next.js - LogRocket](https://blog.logrocket.com/build-monorepo-next-js/)
